# -*- coding: utf-8 -*-
"""
Created on Fri Sep 22 17:27:33 2017

@author: iarey
"""
import numpy as np
import sys

from part_params import Nj, dist_type, sim_repr, idx_bounds, seed, Tpar, Tper, mass, velocity
from const       import dx, dy, NX, NY, cellpart, N, kB, Bc


def particles_per_cell():
    '''Creates a map of how many particles per cell per specices will be placed in the simulation domain. Allows the
    distribution functions to initialize each cell correctly and keep fine scale structure (c.f. Initialization over
    whole domain). Uses parameters specified in  const and part_params.
    
    INPUT:
        <NONE>
        
    OUTPUT:
        ppc -- Number of particles per cell per species over simulation domain
    '''
    ppc = np.zeros((Nj, NX, NY), dtype=int)
    
    for ii in range(Nj):
        if dist_type[ii] == 0:
            ppc[ii, :, :] = cellpart * sim_repr[ii]    
            
        elif  dist_type[ii] == 1:
            sys.exit('Non-unform densities not yet supported by this code. Change dist_type flags to 0 for all species.')
    return ppc


def two_D_uniform(ppc):
    '''Places all particles in a uniform distribution using NumPy's random.uniform routine. Places particles cell by cell in order
    to prevent macroscopic inhomogeneities. Will do for now until a more uniform routine can be written.
    
    INPUT:
        ppc -- Distribution array detailing how many particles are present in each grid cell of simulation, per species
        
    OUTPUT:
        dist -- The resulting distribution as a 2xN numpy array, corresponding to uniformly distributed particle positions
    '''
    dist = np.zeros((2, N))
    np.random.seed(seed)
    for jj in range(Nj):
        acc         = 0
        for ii in range(NX):
            for kk in range(NY):
                n_particles = ppc[jj, ii, kk]
                dist[0, (idx_bounds[jj, 0] + acc): (idx_bounds[jj, 0] + acc + n_particles)] = np.random.uniform(ii, (ii + 1), n_particles) * dx
                dist[1, (idx_bounds[jj, 0] + acc): (idx_bounds[jj, 0] + acc + n_particles)] = np.random.uniform(kk, (kk + 1), n_particles) * dy
                acc += n_particles
    return dist


def normal_distribution(ppc):
    '''Creates a normal distribution of N particles of species type idx subdivided into NX cells to keep the fine
    scale structure.
    
    INPUT:
        N   -- Number of particles to distribute
        idx -- Index identifier for particle type : Correlates to parameters in part_params.py
        
    OUTPUT:
        dist -- Output distribution: Maxwellian, as generated by numpy's random.normal in 3 dimensions
    '''
    np.random.seed(seed)         # Random seed 
    dist = np.zeros((3, N))      # Initialize array

    for jj in range(Nj):
        acc = 0                  # Species accumulator
        for ii in range(NX):
            for kk in range(NY):
                n_particles = ppc[jj, ii, kk]
                dist[0, (idx_bounds[jj, 0] + acc): ( idx_bounds[jj, 0] + acc + n_particles)] = np.random.normal(0, np.sqrt((kB *  Tpar[jj]) /  mass[jj]), n_particles) +  velocity[jj]
                dist[1, (idx_bounds[jj, 0] + acc): ( idx_bounds[jj, 0] + acc + n_particles)] = np.random.normal(0, np.sqrt((kB *  Tper[jj]) /  mass[jj]), n_particles)
                dist[2, (idx_bounds[jj, 0] + acc): ( idx_bounds[jj, 0] + acc + n_particles)] = np.random.normal(0, np.sqrt((kB *  Tper[jj]) /  mass[jj]), n_particles)
                acc += n_particles
    return dist

def initialize_particles():
    '''Initialize particle array with structure:
        part[0, :] -- Position in x
        part[1, :] -- Position in y
        part[2, :] -- Particle species index
        part[3, :] -- Velocity in x
        part[4, :] -- Velocity in y
        part[5, :] -- Velocity in z
        part[6, :] -- Leftmost node
        part[7, :] -- Bottom-most node
        '''
    part     = np.zeros((8, N), dtype=float)                                   # Initialize particle array: Each particle parameter is stored in a contiguous block of memory
    ppc      = particles_per_cell()                                            # Generate number of particles per cell, per species
    
    for jj in range( Nj):
        part[2,  idx_bounds[jj, 0]:  idx_bounds[jj, 1]] = jj                   # Give species index identifier to each particle  
    
    part[0:2, :] = two_D_uniform(ppc)                                          # Initialize particles in configuration space
    part[3:6, :] = normal_distribution(ppc)                                    # Initialize particles in velocity space
    part[6, :]   = part[0, :] / dx + 0.5 ; part[6, :] = part[6, :].astype(int) # Initial leftmost node, Ix
    part[7, :]   = part[1, :] / dy + 0.5 ; part[7, :] = part[7, :].astype(int) # Initial bottom-most node, Iy
    return part


def initialize_fields():   
    '''Initializes field ndarrays and sets initial values for fields based on parameters in  .
    
    INPUT:
        <NONE>
        
    OUTPUT:
        B   -- Magnetic field array
        E   -- Electric field array
        Ji  -- Ion current array
        dns -- Number density array
        W   -- E-node weighting array
        Wb  -- B-node weighting array
    '''
    B = np.zeros((NX + 2, NY + 2, 6), dtype=float)
        # Where:
        #       B[mm, 0-2] represent the current field and
        #       B[mm, 3-5] store the last state of the magnetic field previous to the Predictor-Corrector scheme
    B[:, :, 0] = Bc[0]      # Set Bx initial
    B[:, :, 1] = Bc[1]      # Set By initial
    B[:, :, 2] = Bc[2]      # Set Bz initial
    
    E = np.zeros((NX + 2, NY + 2, 9), dtype=float)
        # Where:
        #       E[mm, 0-2] represent the current field and
        #       E[mm, 3-5] store the last state of the electric field previous to the Predictor-Corrector scheme E (N + 0.5)
        #       E[mm, 6-8] store two steps ago: E-field at E^N
    E[:, :, 0] = 0         # Set Ex initial
    E[:, :, 1] = 0         # Set Ey initial
    E[:, :, 2] = 0         # Set Ez initial
    
    Ji      = np.zeros((NX + 2, NY + 2, Nj, 3), dtype=float)          # Ion Current (3 dimensions)
    dns     = np.zeros((NX + 2, NY + 2, Nj),    dtype=float)          # Species number density in each cell (in /m3)
    W       = np.zeros((4, N),                  dtype=float)          # Particle weights (E-nodes)
    Wb      = np.zeros((4, N),                  dtype=float)          # Particle weights (B-nodes)
    return B, E, Ji, dns, W, Wb    


