# -*- coding: utf-8 -*-
"""
Created on Fri Sep 22 17:27:33 2017

@author: iarey
"""
import numba as nb
import numpy as np
import simulation_parameters_1D as const
import save_routines as save

from particles_1D             import assign_weighting_TSC
from simulation_parameters_1D import dx, NX, ND, NC, N, kB, B0, Nj, dist_type, nsp_ppc,      \
                                     idx_bounds, seed, Tpar, Tper, mass, drift_v, theta, \
                                     r_damp
                                     
@nb.njit()
def particles_per_cell():
    '''
    Calculates how many particles per cell per specices to be placed in the simulation domain. Currently only does
    uniform, but useful shell function for later on.
    
    INPUT:
        <NONE>
        
    OUTPUT:
        ppc -- Number of particles per cell per species for each cell in simulation domain. NjxNX ndarray.
    '''
    ppc = np.zeros((Nj, NX), dtype=nb.int32)

    for ii in range(Nj):
        if dist_type[ii] == 0:
            ppc[ii, :] = nsp_ppc
    return ppc


@nb.njit()
def uniform_gaussian_distribution_quiet(ppc):
    '''Creates an N-sampled normal distribution across all particle species within each simulation cell

    INPUT:
        ppc -- Number of particles per cell to initialize

    OUTPUT:
        dist -- Output distribution: Maxwellian, as generated by numpy's random.normal in 3 dimensions
    '''
    pos = np.zeros(N)
    vel = np.zeros((3, N))      # Initialize array
    idx = np.zeros(N, dtype=np.uint8)
    np.random.seed(seed)        # Random seed

    for jj in range(Nj):                    # For each species
        acc = 0
        idx[idx_bounds[jj, 0]: idx_bounds[jj, 1]] = jj
        
        for ii in range(NX):                # For each cell
            half_n = ppc[jj, ii] // 2       # Assumes ppc contains only even numbers
            st     = idx_bounds[jj, 0] + acc
            en     = idx_bounds[jj, 0] + acc + half_n
            sf_par = np.sqrt((kB *  Tpar[jj]) /  mass[jj])
            sf_per = np.sqrt((kB *  Tper[jj]) /  mass[jj])
            
            for kk in range(half_n):        # For each particle in that cell (half only)
                pos[st + kk] = dx*(float(kk) / half_n + ii)
                
            vel[0, st: en] = np.random.normal(0, sf_par, half_n) +  drift_v[jj]
            vel[1, st: en] = np.random.normal(0, sf_per, half_n)
            vel[2, st: en] = np.random.normal(0, sf_per, half_n)

            pos[   en: en + half_n] = pos[   st: en]            # Other half, same position
            vel[0, en: en + half_n] = vel[0, st: en] * -1.0     # Inverted velocities (v2 = -v1)
            vel[1, en: en + half_n] = vel[1, st: en] * -1.0
            vel[2, en: en + half_n] = vel[2, st: en] * -1.0
            
            acc += half_n * 2
    
    # Rotate if theta != 0
    vel[0] = vel[0] * np.cos(np.pi * theta / 180.) - vel[2] * np.sin(np.pi * theta / 180.)
    vel[2] = vel[2] * np.cos(np.pi * theta / 180.) + vel[0] * np.sin(np.pi * theta / 180.)
    return pos, vel, idx


@nb.njit()
def initialize_particles():
    '''Initializes particle arrays.
    
    INPUT:
        <NONE>
        
    OUTPUT:
        pos    -- Particle position array (1, N)
        vel    -- Particle velocity array (3, N)
        Ie     -- Initial particle positions by leftmost E-field node
        W_elec -- Initial particle weights on E-grid
        Ib     -- Initial particle positions by leftmost B-field node
        W_mag  -- Initial particle weights on B-grid
        idx    -- Particle type index
    '''
    ppc           = particles_per_cell()
    pos, vel, idx = uniform_gaussian_distribution_quiet(ppc)
    
    Ie         = np.zeros(N,      dtype=nb.uint16)
    Ib         = np.zeros(N,      dtype=nb.uint16)
    W_elec     = np.zeros((3, N), dtype=nb.float64)
    W_mag      = np.zeros((3, N), dtype=nb.float64)
    
    assign_weighting_TSC(pos, Ie, W_elec)
    assign_weighting_TSC(pos, Ib, W_mag, E_nodes=False)
    return pos, vel, Ie, W_elec, Ib, W_mag, idx

#import matplotlib.pyplot as plt; import sys; import pdb
@nb.njit()
def create_damping_array():
    '''Create masking array for magnetic field damping used to apply open
    boundaries. Based on applcation by Shoji et al. (2011) and
    Umeda et al. (2001)
    
    Shoji's application multiplies by the resulting field before it 
    is returned at each timestep (or each time called?), but Umeda's variant 
    includes a damping on the increment as well as the solution, with a
    different r for each (one damps, one changes the phase velocity and
    increases the "effective damping length").
    
    Also, using Shoji's parameters, mask at most damps 98.7% at end grid 
    points. Relying on lots of time spend there? Or some sort of error?
    Can just play with r value/damping region length once it doesn't explode.
    '''
    damping_array = np.ones(NC + 1)                  # Blank damping array
    array_nums    = np.arange(NC + 1)                # Array numbers
    midpoint      = 0.5*NC                           # Midpoint value
    dist_from_mp  = np.abs(array_nums - midpoint)    # Distance of each B-node from midpoint
    
    for ii in range(NC + 1):
        if dist_from_mp[ii] > 0.5*NX:
            damping_array[ii] = 1. - r_damp * ((dist_from_mp[ii] - 0.5*NX) / ND) ** 2 
    
    return damping_array


@nb.njit()
def initialize_fields():
    '''Initializes field ndarrays and sets initial values for fields based on
       parameters in config file.

    INPUT:
        <NONE>

    OUTPUT:
        B      -- Magnetic field array: Node locations on cell edges/vertices
        E_int  -- Electric field array: Node locations in cell centres
        E_half -- Electric field array: Node locations in cell centres
        Ve     -- Electron fluid velocity moment: Calculated as part of E-field update equation
        Te     -- Electron temperature          : Calculated as part of E-field update equation          
    '''
    Bc      = np.zeros(3)                                 # Constant components of magnetic field based on theta and B0
    Bc[0]   = B0 * np.cos(theta * np.pi / 180.)           # Constant x-component of magnetic field (theta in degrees)
    Bc[1]   = 0.                                          # Assume Bzc = 0, orthogonal to field line direction
    Bc[2]   = B0 * np.sin(theta * np.pi / 180.)           # Constant y-component of magnetic field (theta in degrees)
    
    B       = np.zeros((NC + 1, 3), dtype=np.float64)
    E_int   = np.zeros((NC    , 3), dtype=np.float64)
    E_half  = np.zeros((NC    , 3), dtype=np.float64)

    B[:, 0] = Bc[0]      # Set Bx initial
    B[:, 1] = Bc[1]      # Set By initial
    B[:, 2] = Bc[2]      # Set Bz initial
    
    Ve      = np.zeros((NC, 3), dtype=np.float64)
    Te      = np.zeros( NC,     dtype=np.float64)
    
    damping_array = create_damping_array()
    
    return B, E_int, E_half, Ve, Te, damping_array


@nb.njit()
def initialize_source_arrays():
    '''Initializes source term ndarrays. Each term is collected on the E-field grid.

    INPUT:
        <NONE>

    OUTPUT:
        q_dens  -- Total ion charge  density
        q_dens2 -- Total ion charge  density (used for averaging)
        Ji      -- Total ion current density
        ni      -- Ion number density per species
        nu      -- Ion velocity "density" per species
    '''
    q_dens  = np.zeros( NC,          dtype=nb.float64)    
    q_dens2 = np.zeros( NC,          dtype=nb.float64) 
    Ji      = np.zeros((NC, 3),     dtype=nb.float64)
    ni      = np.zeros((NC, Nj),    dtype=nb.float64)
    nu      = np.zeros((NC, Nj, 3), dtype=nb.float64)
    return q_dens, q_dens2, Ji, ni, nu


@nb.njit()
def initialize_tertiary_arrays():
    '''Initializes source term ndarrays. Each term is collected on the E-field grid.

    INPUT:
        <NONE>
        
    OUTPUT:
        temp3Db       -- Swap-file vector array with B-grid dimensions
        temp3De       -- Swap-file vector array with E-grid dimensions
        temp1D        -- Swap-file scalar array with E-grid dimensions
        old_particles -- Location to store old particle values (positions, velocities, weights)
                         as part of predictor-corrector routine
        old_fields   -- Location to store old B, Ji, Ve, Te field values for predictor-corrector routine
    '''
    temp3Db       = np.zeros((NC + 1, 3),  dtype=nb.float64)
    temp3De       = np.zeros((NC    , 3),  dtype=nb.float64)
    temp1D        = np.zeros( NC    ,      dtype=nb.float64) 
    old_fields    = np.zeros((NC + 1, 10), dtype=nb.float64)
    
    old_particles = np.zeros((8, N),          dtype=nb.float64)
    
    return old_particles, old_fields, temp3De, temp3Db, temp1D


def set_timestep(vel):
    '''
    INPUT:
        vel -- Initial particle velocities
    OUTPUT:
        DT              -- Maximum allowable timestep (seconds)
        max_inc         -- Number of integer timesteps to get to end time
        part_save_iter  -- Number of timesteps between particle data saves
        field_save_iter -- Number of timesteps between field    data saves
    
    Note : Assumes no dispersion effects or electric field acceleration to
           be initial limiting factor. This may change for inhomogenous loading
           of particles or initial fields.
    '''
    gyperiod = (2*np.pi) / const.gyfreq               # Gyroperiod within uniform field, initial B0 (s)         
    ion_ts   = const.orbit_res * gyperiod             # Timestep to resolve gyromotion
    vel_ts   = 0.5 * const.dx / np.max(vel[0, :])     # Timestep to satisfy CFL condition: Fastest particle doesn't traverse more than half a cell in one time step 

    DT       = min(ion_ts, vel_ts)
    max_time = const.max_rev * gyperiod               # Total runtime in seconds
    max_inc  = int(max_time / DT) + 1                 # Total number of time steps

    if const.part_res == 0:
        part_save_iter = 1
    else:
        part_save_iter = int(const.part_res*gyperiod / DT)

    if const.field_res == 0:
        field_save_iter = 1
    else:
        field_save_iter = int(const.field_res*gyperiod / DT)

    if const.save_fields == 1 or const.save_particles == 1:
        save.store_run_parameters(DT, part_save_iter, field_save_iter)

    print('Timestep: %.4fs, %d iterations total\n' % (DT, max_inc))
    return DT, max_inc, part_save_iter, field_save_iter



# =============================================================================
# if __name__ == '__main__':
#     # TEST DAMPING ARRAY
#     # 10 REAL CELLS, 5 DAMPED ON EITHER SIDE
#     # 20 CELLS MEAN 21 B-GRID POINTS
#     # NEED TO DAMP FOR ALL THESE
#     NX = 5
#     ND = 20
#     NC = 2*ND + NX
#     r_damp = 0.5
#     
#     create_damping_array()
# =============================================================================
