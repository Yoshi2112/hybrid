# -*- coding: utf-8 -*-
"""
Created on Fri Sep 22 17:27:33 2017

@author: iarey
"""
import numpy as np
import pdb

from part_params import Nj, dist_type, N_species, sim_repr, idx_bounds, seed, Tpar, Tper, mass, velocity
from const       import dx, NX, cellpart, k, N, kB, Bc


def particles_per_cell():
    '''Creates a map of how many particles per cell per specices will be placed in the simulation domain. Allows the
    distribution functions to initialize each cell correctly and keep fine scale structure (c.f. Initialization over
    whole domain). Uses parameters specified in  const and part_params.
    INPUT:
        <NONE>
    OUTPUT:
        ppc -- Number of particles per cell per species over simulation domain
    '''
    ppc = np.zeros((Nj, NX), dtype=int)
    
    for ii in range(Nj):
        if dist_type[ii] == 0:
            ppc[ii, :] = cellpart * sim_repr[ii]    
            
        elif  dist_type[ii] == 1:
            x_cell  = np.arange(0,  NX*dx, dx)                 # Array with distance boundaries between cells
            sx      = np.ones(NX)                                  # Initialize distrbution function
        
            for jj in range(NX):                                   # Create sinusoidal distribution function
                sx[jj] = (0.5 * np.sin((2*np.pi*k /  NX*dx) * x_cell[jj])) + 1
        
            sx /= np.sum(sx)                                             # Normalize sinusoidal distribution function
        
            ppc[jj, :] = (np.round(sx *  N_species[jj]))               # Generate number of particles per cell
        
            if np.sum(ppc[jj, :]) != N:       							      # Check total: Can be avoided by picking NX mod k = 0
                diff = N - np.sum(ppc[jj, :])                      # Find how many particles short
                idxs = np.random.randint(0, NX - 1, diff)          # Create random indices to put them (very small error)
                for ext in idxs:
                    ppc[jj, ext] += 1                                    # Put an extra particle in them  
    return ppc

def uniform_distribution(ppc):
    '''Creates an analytically uniform distribution of N numbers within each cell boundary
    
    INPUT:
        ppc       -- Number of particles per cell, per species
        
    OUTPUT:
        dist -- numpy ndarray containing numerical distribution
    '''
    dist = np.zeros(N)
    
    for jj in range(Nj):                    # For each species
        acc = 0
        for ii in range(NX):                # For each cell
            n_particles = ppc[jj, ii]
            
            for kk in range(n_particles):   # For each particle in that cell
                dist[idx_bounds[jj, 0] + acc + kk] = dx*(float(kk) / n_particles + ii)
            acc += n_particles
    return dist


def normal_distribution(ppc):
    '''Creates a normal distribution of N particles of species type idx subdivided into NX cells to keep the fine
    scale structure.
    
    INPUT:
        N   -- Number of particles to distribute
        idx -- Index identifier for particle type : Correlates to parameters in part_params.py
        
    OUTPUT:
        dist -- Output distribution: Maxwellian, as generated by numpy's random.normal in 3 dimensions
    '''
    np.random.seed(seed)         # Random seed 
    dist = np.zeros((3, N))      # Initialize array

    for jj in range(Nj):
        acc = 0                  # Species accumulator
        for ii in range(NX):
            n_particles = ppc[jj, ii]
            dist[0, (idx_bounds[jj, 0] + acc): ( idx_bounds[jj, 0] + acc + n_particles)] = np.random.normal(0, np.sqrt((kB *  Tpar[jj]) /  mass[jj]), n_particles) +  velocity[jj]
            dist[1, (idx_bounds[jj, 0] + acc): ( idx_bounds[jj, 0] + acc + n_particles)] = np.random.normal(0, np.sqrt((kB *  Tper[jj]) /  mass[jj]), n_particles)
            dist[2, (idx_bounds[jj, 0] + acc): ( idx_bounds[jj, 0] + acc + n_particles)] = np.random.normal(0, np.sqrt((kB *  Tper[jj]) /  mass[jj]), n_particles)
            acc += n_particles
    
    return dist

def initialize_particles():
    '''Initialize particle array with structure:
        part[0, :] -- Position in x
        part[1, :] -- Position in y (unused for 1D)
        part[2, :] -- Particle species index
        part[3, :] -- Velocity in x
        part[4, :] -- Velocity in y
        part[5, :] -- Velocity in z
        part[6, :] -- Leftmost node
        '''
    part     = np.zeros((7, N), dtype=float)                                  # Initialize particle array
    ppc      = particles_per_cell()                                                 # Generate number of particles per cell, per species
    
    for jj in range( Nj):
        part[2,  idx_bounds[jj, 0]:  idx_bounds[jj, 1]] = jj                              # Give species index identifier to each particle  
    
    part[0, :]   = uniform_distribution(ppc)                                        # Initialize particles in configuration space
    part[3:6, :] = normal_distribution(ppc)                                         # Initialize particles in velocity space
    part[6, :]   = part[0, :] / dx + 0.5 ; part[6, :] = part[6, :].astype(int)# Initial leftmost node, I
    return part


def initialize_fields():   
    '''Initializes field ndarrays and sets initial values for fields based on parameters in  .
    
    INPUT:
        <NONE>
        
    OUTPUT:
        B   -- Magnetic field array
        E   -- Electric field array
        Ji  -- Ion current array
        dns -- Number density array
        W   -- E-node weighting array
        Wb  -- B-node weighting array
    '''
    B = np.zeros(( NX + 2, 6), dtype=float)
        # Where:
        #       B[mm, 0-2] represent the current field and
        #       B[mm, 3-5] store the last state of the magnetic field previous to the Predictor-Corrector scheme
    B[:, 0] = Bc[0]      # Set Bx initial
    B[:, 1] = Bc[1]      # Set By initial
    B[:, 2] = Bc[2]      # Set Bz initial
    
    E = np.zeros(( NX + 2, 9), dtype=float)
        # Where:
        #       E[mm, 0-2] represent the current field and
        #       E[mm, 3-5] store the last state of the electric field previous to the Predictor-Corrector scheme E (N + 0.5)
        #       E[mm, 6-8] store two steps ago: E-field at E^N
    E[:, 0] = 0         # Set Ex initial
    E[:, 1] = 0         # Set Ey initial
    E[:, 2] = 0         # Set Ez initial
    
    Ji      = np.zeros(( NX + 2, Nj, 3), dtype=float)          # Ion Current (3 dimensions)
    dns     = np.zeros(( NX + 2, Nj),    dtype=float)          # Species number density in each cell (in /m3)
    W       = np.zeros(N,             dtype=float)                # Particle Weights (E-nodes)
    Wb      = np.zeros(N,             dtype=float)                # Particle Weights (B-nodes)
    return B, E, Ji, dns, W, Wb    